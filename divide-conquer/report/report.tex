\documentclass[10pt,twocolumn]{article}

\usepackage{geometry}
\geometry{
	a4paper,
	left=1cm,
	top=1cm,
	right=1cm,
	bottom=1cm,
}
\usepackage{color}
\usepackage[toc,page]{appendix}
\usepackage{authblk}
\usepackage{amsmath}
\usepackage{url}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{multicol}

\definecolor{mygray}{rgb}{0.4,0.4,0.4}

\lstdefinestyle{cppStyle}{
	captionpos=t,
	numbers=left,
	% xleftmargin=8pt,
	numberstyle=\color{mygray}\ttfamily\small,
	numbersep=8pt,
	language=c++,
	keywordstyle=\color{blue}\small,
	stringstyle=\color{red}\small,
	commentstyle=\color{green}\small,
	basicstyle=\ttfamily\small,
	showstringspaces=false,
	breaklines,
	escapechar=|,
	columns=fullflexible,
}

\pagenumbering{gobble}

\begin{document}

\title{\vspace{-1cm}Bubble Sort using Divide and Conquer with MPI}
\author[1]{Claudio Scheer}
\author[1]{Gabriell Araujo}
\affil[1]{Master's Degree in Computer Science - PUCRS}
\affil[ ]{\textit{\{claudio.scheer, grabriell.araujo\}@edu.pucrs.br}}
\date{}

\maketitle

\section*{General Setup}
We ran our \textit{batch job} on two nodes (2x24 cores) in the Cerrado cluster. All experiments were executed three times and then the average execution time and the standard deviation were calculated. For the implementation using MPI, we used the master-slave architecture. In short, the slave asks the master for a job, the master sends the job to the slave, the slave processes the job and returns the result. The master waits for the slave's results using an asynchronous call. Finally, when all jobs are completed, the master waits for all the asynchronous results of the slaves and asks the slave to `commit suicide'\footnote{What a horrible scenario!}.

\section*{Bubble Sort}
The bubble sort problem addressed here consists of sorting 1000 vectors with 2500 integers. Each slave receives a vector to sort and return the sorted vector to the master. Figure~\ref{fig:bubble-sort-time} shows the results of the executions using the sequential (Listing~\ref{lst:bubble-sort-sequential}) and the MPI version (Listing~\ref{lst:bubble-sort-mpi}), with different numbers of slaves.

As the number of processes increases, the execution time is shorter. However, the efficiency of the parallel execution grows slowly from 4 to 12 processes. Even so, the efficiency of the bubble sort with MPI reaches 83.14\%. This indicates that, up to 12 processes, the bubble sort algorithm can exploit up to 83.14\% of the expected speedup.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.45\textwidth]{../logs/scripts/bubble-sort-speedup-efficiency.pdf}
	\caption{Speedup x Efficiency}
	\label{fig:bubble-sort-speedup-efficiency}
\end{figure}

Figure~\ref{fig:bubble-sort-speedup-efficiency} shows that the speedup grows linearly for physical cores. However, when using hyper-threading, the speedup is only 28.31\% effective when compared to the number of processes. Another fact is that when the cores are in different nodes, speedup and efficiency begins to decrease.

\section*{Discussion}
In linear regression, hyper-threading increased the execution time when compared to the approach using all physical cores and the efficiency was only 3.9\%. For bubble sort, hyper-threading has almost the same speedup as using all physical cores, but not as efficient as using only physical cores. Therefore, in general, hyper-threading can have a speedup, but efficiency tends to decrease. In addition, depending of the problem addressed using MPI and master-slave architecture, more processes can decrease the speedup.

The main difference between the two problems is the speedup as the number of processes increases. Bubble sort will have a linear growth, while linear regression has a point where, even with more physical cores, the speedup stabilizes and begins to decrease.

\onecolumn

\section*{Bubble Sort Source Code}
\lstinputlisting[caption=Dataset generator,style=cppStyle]{../bubble-sort/dataset-generator.cpp}
\lstinputlisting[caption=Bubble Sort Sequential,label=lst:bubble-sort-sequential,style=cppStyle]{../bubble-sort/sort-seq.cpp}
\lstinputlisting[caption=Bubble Sort MPI,label=lst:bubble-sort-mpi,style=cppStyle]{../bubble-sort/sort-mpi.cpp}

\end{document}
